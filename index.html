const parseRecipes = (data) => {
    const recipeMap = {};
    // 첫 번째 줄(헤더)을 제외하고 데이터 분석
    data.slice(1).forEach(row => {
        const name = (row[0] || "").trim(); // A열: 레시피명
        if (name) {
            recipeMap[name] = {
                name: name,
                keywords: (row[1] || "").trim(),    // B열: 매칭 키워드
                ingredients: (row[2] || "").trim(), // C열: 식재료
                process: (row[3] || "").trim(),     // D열: 조리공정
                tip: (row[4] || "").trim()          // E열: 전문가 TIP
            };
        }
    });
    return recipeMap;
};

// [추가 수정] 레시피 검색 로직도 더 강력하게 변경 (매칭 키워드 기반)
const findMatchedRecipes = (menuName) => {
    if (!menuName || menuName === "일정없음") return [];
    const target = menuName.replace(/\s/g, "");
    
    return Object.values(recipes).filter(r => {
        const rName = r.name.replace(/\s/g, "");
        const keywords = r.keywords.split(',').map(k => k.trim().replace(/\s/g, ""));
        
        // 1. 레시피 이름이 메뉴명에 포함되거나
        // 2. 매칭 키워드 중 하나라도 메뉴명에 포함되면 출력
        return target.includes(rName) || keywords.some(k => k && target.includes(k));
    });
};
